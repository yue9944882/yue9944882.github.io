<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="Hugo 0.74.3" />

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="" />
  <meta property="og:url" content="https://yue9944882.github.io/posts/how-to-trace-kubernetes-operators/" />
  <link rel="canonical" href="https://yue9944882.github.io/posts/how-to-trace-kubernetes-operators/" /><link rel="alternate" type="application/atom+xml" href="https://yue9944882.github.io/index.xml" title="Undersurface Kubernetes">

  <script type="application/ld+json">
  {
      "@context" : "http://schema.org",
      "@type" : "BlogPosting",
      "mainEntityOfPage": {
           "@type": "WebPage",
           "@id": "https:\/\/yue9944882.github.io\/"
      },
      "articleSection" : "posts",
      "name" : "Is Tracing Kubernetes Operators Feasible?",
      "headline" : "Is Tracing Kubernetes Operators Feasible?",
      "description" : "Is it feasible to trace those operators running in kubernetes cluster? Currently there\u0026rsquo;re two major approaches to monitor your operator instances \u0026ndash; metrics and logging. Metrics does well in measuring your operator in concrete numbers at runtime, and by logging you can record running details into disk files in any format. However neither of them are helpful in showing the correlation between instances\/services. Distributed tracing is well-suited for microservice architectures, especially in which the services are serving in a synchronous protocol e.",
      "inLanguage" : "en-US",
      "author" : "",
      "creator" : "",
      "publisher": "",
      "accountablePerson" : "",
      "copyrightHolder" : "",
      "copyrightYear" : "2020",
      "datePublished": "2020-08-02 01:18:56 \u002b0800 CST",
      "dateModified" : "2020-08-02 01:18:56 \u002b0800 CST",
      "url" : "https:\/\/yue9944882.github.io\/posts\/how-to-trace-kubernetes-operators\/",
      "keywords" : [  ]
  }
</script>
<title>Is Tracing Kubernetes Operators Feasible? - Undersurface Kubernetes</title>
  <meta property="og:title" content="Is Tracing Kubernetes Operators Feasible? - Undersurface Kubernetes" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="Is it feasible to trace those operators running in kubernetes cluster? Currently there&rsquo;re two major approaches to monitor your operator instances &ndash; metrics and logging. Metrics does well in measuring your operator in concrete numbers at runtime, and by logging you can record running details into disk files in any format. However neither of them are helpful in showing the correlation between instances/services. Distributed tracing is well-suited for microservice architectures, especially in which the services are serving in a synchronous protocol e." />
  <meta name="description" content="Is it feasible to trace those operators running in kubernetes cluster? Currently there&rsquo;re two major approaches to monitor your operator instances &ndash; metrics and logging. Metrics does well in measuring your operator in concrete numbers at runtime, and by logging you can record running details into disk files in any format. However neither of them are helpful in showing the correlation between instances/services. Distributed tracing is well-suited for microservice architectures, especially in which the services are serving in a synchronous protocol e." />
  <meta property="og:locale" content="en-us" />

  <link rel="stylesheet" href="/css/flexboxgrid-6.3.1.min.css" />
  <link rel="stylesheet" href="/css/github-markdown.css" />
  <link rel="stylesheet" href="/css/highlight/tomorrow.min.css" />
  <link rel="stylesheet" href="/css/index.css">

  

  <link href="/index.xml" rel="alternate" type="application/rss+xml"
    title="Undersurface Kubernetes">
  
  <link href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker|Bree+Serif" rel="stylesheet">
  
  

  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-xxx"></script>
</head>

<body>
  <article class="post " id="article">
    <div class="row">
      <div class="col-xs-12">
        <div class="site-header">
          
<header>
  <div class="signatures site-title">
    <a href="/">Donate Kubernetes Maintainer</a>
  </div>
</header>
<div class="row end-xs">
  
  
</div>
<div class="header-line"></div>

        </div>
        <header class="post-header">
          <h1 class="post-title">Is Tracing Kubernetes Operators Feasible?</h1>
          
          <div class="row post-desc">
            <div class="col-xs-6">
              
              <time class="post-date" datetime="2020-08-02 01:18:56 CST">
                02 Aug 2020
              </time>
              
            </div>
            <div class="col-xs-6">
              
            </div>
          </div>
          
        </header>

        <div class="post-content markdown-body">
          
          <p>Is it feasible to trace those operators running in kubernetes cluster? Currently
there&rsquo;re two major approaches to monitor your operator instances &ndash; metrics and
logging. Metrics does well in measuring your operator in concrete numbers at runtime,
and by logging you can record running details into disk files in any format. However
neither of them are helpful in showing the correlation between instances/services.
Distributed tracing is well-suited for microservice architectures, especially in which
the services are serving in a synchronous protocol e.g. HTTP, gRPC. Sadly that doesn&rsquo;t
apply to kubernetes operator pattern. An operator is working completely asynchronously,
stimulated by the watching event feed from kubernetes apiserver. In this blog, we will
get a deep insight into the feasibility of plumbing distributed tracing on the operator
pattern.</p>

        </div>

        <div class="row middle-xs">
          <div class="col-xs-12">
            
          </div>
        </div>
        <div class="row">
          <div class="col-xs-12">
            
          </div>
        </div>

        
        

        
        
        <div style="height: 50px;"></div>
        
        <div class="post-comments">
          <div id="disqus_thread"></div>
<script>
  window.addEventListener("load", () => {
    (function() {
      
      var d = document,
        s = d.createElement("script");
      s.src = "https://yue9944882.disqus.com/embed.js";
      s.setAttribute("data-timestamp", +new Date());
      (d.head || d.body).appendChild(s);
    })();
  });
</script>
<noscript
  >Please enable JavaScript to view the
  <a href="https://disqus.com/?ref_noscript"
    >comments powered by Disqus.</a
  ></noscript
>

        </div>
        
        

        <div class="site-footer">
  
  <div class="site-footer-item">
    <a href="about.html" target="_blank">About</a>
  </div>
  
  <div class="site-footer-item">
    <a href="https://github.com/yue9944882" target="_blank">Github</a>
  </div>
  
  <div class="site-footer-item">
    <a href="https://paypal.me/yue9944882" target="_blank">Donate-PayPal</a>
  </div>
  
  <div class="site-footer-item">
    <a href="https://github.com/yue9944882/hugo/blob/master/wechat.JPG?raw=true" target="_blank">Donate-Wechat</a>
  </div>
  
  <div class="site-footer-item">
    <a href="https://github.com/yue9944882/hugo/blob/master/alipay.JPG?raw=true" target="_blank">Donate-Alipay</a>
  </div>
  
  
</div>

      </div>
    </div>
  </article>

  <script src="/js/highlight.pack.js"></script>


<script>
  hljs.initHighlightingOnLoad();
  
  
  
    
    
  
</script>

  

</body>

</html>